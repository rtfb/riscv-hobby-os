#!/usr/bin/env python3

from dataclasses import dataclass
from io import StringIO
from typing import Callable


@dataclass
class Param:
    input: str
    type: str
    name: str
    array_qual: str


@dataclass
class SyscallDecl:
    full_input: str
    ret_type: str
    decl: str
    func_name: str
    syscall_num: str
    params: list[Param]


@dataclass
class GenFile:
    filename: str
    generator: Callable[[list[SyscallDecl]], str]


def parse_params(input: str) -> list[Param]:
    if input == '':
        return []
    plist = input.split(',')
    result = []
    for p in plist:
        array_qual = ''
        type, _, name = p.strip().rpartition(' ')
        if name.startswith('*'):
            type += '*'
            name = name[1:]
        if name.startswith('*'):
            type += '*'
            name = name[1:]
        if name.endswith(']'):
            open_sq_br = name.find('[')
            array_qual = name[open_sq_br:]
            name = name[:open_sq_br]
        result.append(Param(p, type, name, array_qual))
    return result


def parse(input: str) -> SyscallDecl:
    syscall_num, _, decl = input.partition(': ')
    decl = decl.strip()
    # ret_type, decl = input.split(maxsplit=1)
    ret_type = 'regsize_t'
    func_name, _, temp = decl.partition('(')
    params_str, _, _ = temp.partition(')')
    params = parse_params(params_str)
    return SyscallDecl(input, ret_type, decl, func_name, syscall_num, params)


def gen_usyscalls_h(data: list[SyscallDecl]) -> str:
    f = StringIO()
    f.write('#include "syscalls.h"\n')
    for d in data:
        f.write(f'extern {d.ret_type} {d.decl}\n')
    return f.getvalue()


def gen_usyscalls_s(data: list[SyscallDecl]) -> str:
    f = StringIO()
    f.write('''#include "syscallnums.h"

// for fun let\'s pretend syscall is kinda like Linux: syscall nr in a7, other
// arguments in a0..a6')
.macro  macro_syscall nr
        li      a7, \\nr
        ecall
.endm
''')
    f.write('\n.balign 4\n')
    f.write('.section .user_text\n')
    for d in data:
        f.write(f'\n.globl {d.func_name}\n')
        f.write(f'{d.func_name}:\n')
        f.write(f'        macro_syscall SYS_NR_{d.func_name}\n')
        f.write(f'        ret\n')
    return f.getvalue()


def gen_syscallnums(data: list[SyscallDecl]) -> str:
    f = StringIO()
    for d in data:
        f.write(f'#define SYS_NR_{d.func_name}'.ljust(32) + f'{d.syscall_num}\n')
    greatest_syscall_num = max(map(lambda d: int(d.syscall_num), data))
    f.write(f'\n#define SYSCALL_VECTOR_LEN      {greatest_syscall_num}\n')
    return f.getvalue()


def gen_syscalls(data: list[SyscallDecl]) -> None:
    f = StringIO()
    f.write('''
#include "proc.h"
#include "syscalls.h"

// for fun let's pretend syscall table is kinda like 32bit Linux on x86,
// /usr/include/asm/unistd_32.h: __NR_restart_syscall 0, __NR_exit 1, _NR_fork 2, __NR_read 3, __NR_write 4
//
// Note that we place syscall_vector in a .text segment in order to have it in
// ROM, since it's read-only after all.
''')
    f.write('void *syscall_vector[] _text = {\n')
    for d in data:
        f.write(f'    [SYS_NR_{d.func_name}]'.ljust(32) + f'sys_{d.func_name},\n')
    f.write('};\n')
    for d in data:
        f.write(f'\n{d.ret_type} sys_{d.func_name}() {{\n')
        for i, p in enumerate(d.params):
            type = p.type
            if p.array_qual != '':
                type += '*'
            f.write(f'    {type} {p.name} = ({type})trap_frame.regs[REG_A{i}];\n')
        calllist = ', '.join([p.name for p in d.params])
        f.write(f'    return proc_{d.func_name}({calllist});\n')
        f.write('}\n')
    return f.getvalue()


def gen_syscalldecls(data: list[SyscallDecl]) -> str:
    f = StringIO()
    f.write('''#ifndef _SYSCALLDECLS_H_
#define _SYSCALLDECLS_H_

''')
    for d in data:
        f.write(f'regsize_t sys_{d.func_name}();\n')
    f.write('#endif\n')
    return f.getvalue()


def load_data(filename: str) -> list[SyscallDecl]:
    ilines = open(filename).readlines()
    data = []
    for line in ilines:
        if line.strip() == '':
            continue
        if line.startswith('//'):
            continue
        data.append(parse(line))
    return data


def main():
    data = load_data('include/syscalls.hh')
    gens = [
        GenFile('user/inc/usyscalls.h', gen_usyscalls_h),
        GenFile('user/src/usyscalls.S', gen_usyscalls_s),
        GenFile('include/syscallnums.h', gen_syscallnums),
        GenFile('src/syscalls.c', gen_syscalls),
        GenFile('include/syscalldecls.h', gen_syscalldecls),
    ]
    for g in gens:
        fo = open(g.filename, 'w')
        fo.write('''// This file is generated by scripts/gen-syscalls.py from include/syscalls.hh.
// To add a new system call, edit syscalls.hh. gen-syscalls.py will be rerun on
// the next build and this file will be modified. Commit in the changed file for
// easier readability.
''')
        fo.write(g.generator(data))
        fo.flush()


if __name__ == '__main__':
    main()
